import { matcherHint, printExpected, printReceived } from 'jest-matcher-utils';
import path from 'path';

const printPass$o = () => () => `${matcherHint('.not.toBeAlwaysCalledOn', 'sinon.spy', 'obj')}\n\n` + `Expected spy to have ${printExpected('not always been called on obj')}, ` + `instead received a spy that has ${printReceived('always been called on obj')}`;

const printFail$o = () => () => `${matcherHint('.toBeAlwaysCalledOn', 'sinon.spy', 'obj')}\n\n` + `Expected spy to have ${printExpected('always been called on obj')}, ` + `instead received a spy that has ${printReceived('not always been called on obj')}`;

var assertion$o = ((expected, obj) => {
  return expected.alwaysCalledOn(obj) ? {
    pass: true,
    message: printPass$o()
  } : {
    pass: false,
    message: printFail$o()
  };
});

const printPass$n = () => () => `${matcherHint('.not.toBeAlwaysCalledWith', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('not been called with correct arguments')}, ` + `instead received a spy that has ${printReceived('been called with correct arguments')}`;

const printFail$n = () => () => `${matcherHint('.toBeAlwaysCalledWith', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('been called with correct arguments')}, ` + `instead received a spy that has ${printReceived('not been called with correct arguments')}`;

var assertion$n = ((expected, ...rest) => {
  return expected.alwaysCalledWith(...rest) ? {
    pass: true,
    message: printPass$n()
  } : {
    pass: false,
    message: printFail$n()
  };
});

const printPass$m = () => () => `${matcherHint('.not.toBeAlwaysCalledWithExactly', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('not been called with correct arguments')}, ` + `instead received a spy that has ${printReceived('been called with correct arguments')}`;

const printFail$m = () => () => `${matcherHint('.toBeAlwaysCalledWithExactly', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('been called with correct arguments')}, ` + `instead received a spy that has ${printReceived('not been called with correct arguments')}`;

var assertion$m = ((expected, ...rest) => {
  return expected.alwaysCalledWithExactly(...rest) ? {
    pass: true,
    message: printPass$m()
  } : {
    pass: false,
    message: printFail$m()
  };
});

const printPass$l = () => () => `${matcherHint('.not.toBeAlwaysCalledWithMatch', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('not been called with correct arguments')}, ` + `instead received a spy that has ${printReceived('been called with correct arguments')}`;

const printFail$l = () => () => `${matcherHint('.toBeAlwaysCalledWithMatch', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('been called with correct arguments')}, ` + `instead received a spy that has ${printReceived('not been called with correct arguments')}`;

var assertion$l = ((expected, ...rest) => {
  return expected.alwaysCalledWithMatch(...rest) ? {
    pass: true,
    message: printPass$l()
  } : {
    pass: false,
    message: printFail$l()
  };
});

const printPass$k = () => () => `${matcherHint('.not.toBeAlwaysCalledWithNew', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('not always been called with new')}, ` + `instead received a spy that has ${printReceived('always been called with new')}`;

const printFail$k = () => () => `${matcherHint('.toBeAlwaysCalledWithNew', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('always been called with new')}, ` + `instead received a spy that has ${printReceived('not always been called with new')}`;

var assertion$k = (expected => {
  return expected.alwaysCalledWithNew() ? {
    pass: true,
    message: printPass$k()
  } : {
    pass: false,
    message: printFail$k()
  };
});

/**
 * A hack to get around the Package entry points used by jest
 */
// eslint-disable-next-line import/no-dynamic-require

const spyMatchers = require(`${path.dirname(require.resolve('expect'))}/spyMatchers.js`).default;

var isSinonSpy = (potentialSpy => {
  return typeof potentialSpy.getCall === 'function' && typeof potentialSpy.alwaysCalledWithExactly === 'function' && typeof potentialSpy.alwaysReturned === 'function';
});

const printPass$j = spy => () => `${matcherHint('.not.toBeCalled', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('not been called')}, ` + `instead received a spy that has been called ${printReceived(spy.callCount)} time(s)`;

const printFail$j = spy => () => `${matcherHint('.toBeCalled', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('been called')}, ` + `instead received a spy that has been called ${printReceived(spy.callCount)} time(s)`;

var assertion$j = (expected => {
  if (isSinonSpy(expected)) {
    return expected.called ? {
      pass: true,
      message: printPass$j(expected)
    } : {
      pass: false,
      message: printFail$j(expected)
    };
  }

  return spyMatchers.toHaveBeenCalled(expected);
});

const printPass$i = () => () => `${matcherHint('.not.toBeCalledAfter', 'sinon.spy', 'sinon.spy')}\n\n` + `Expected spies to have ${printExpected('not been called in order')}`;

const printFail$i = () => () => `${matcherHint('.toBeCalledAfter', 'sinon.spy', 'sinon.spy')}\n\n` + `Expected spies to have ${printExpected('been called in order')}`;

var assertion$i = ((expected, anotherSpy) => {
  return expected.calledAfter(anotherSpy) ? {
    pass: true,
    message: printPass$i()
  } : {
    pass: false,
    message: printFail$i()
  };
});

const printPass$h = () => () => `${matcherHint('.not.toBeCalledBefore', 'sinon.spy', 'sinon.spy')}\n\n` + `Expected spies to have ${printExpected('not been called in order')}`;

const printFail$h = () => () => `${matcherHint('.toBeCalledBefore', 'sinon.spy', 'sinon.spy')}\n\n` + `Expected spies to have ${printExpected('been called in order')}`;

var assertion$h = ((expected, anotherSpy) => {
  return expected.calledBefore(anotherSpy) ? {
    pass: true,
    message: printPass$h()
  } : {
    pass: false,
    message: printFail$h()
  };
});

const printPass$g = () => () => `${matcherHint('.not.toBeCalledImmediatelyAfter', 'sinon.spy', 'sinon.spy')}\n\n Expected spies to have ${printExpected('not been called in order')}`;

const printFail$g = () => () => `${matcherHint('.toBeCalledImmediatelyAfter', 'sinon.spy', 'sinon.spy')}\n\n Expected spies to have ${printExpected('been called in order')}`;

var assertion$g = ((expected, anotherSpy) => {
  return expected.calledImmediatelyAfter(anotherSpy) ? {
    pass: true,
    message: printPass$g()
  } : {
    pass: false,
    message: printFail$g()
  };
});

const printPass$f = () => () => `${matcherHint('.not.toBeCalledImmediatelyBefore', 'sinon.spy', 'sinon.spy')}\n\n Expected spies to have ${printExpected('not been called in order')}`;

const printFail$f = () => () => `${matcherHint('.toBeCalledImmediatelyBefore', 'sinon.spy', 'sinon.spy')}\n\n Expected spies to have ${printExpected('been called in order')}`;

var assertion$f = ((expected, anotherSpy) => {
  return expected.calledImmediatelyBefore(anotherSpy) ? {
    pass: true,
    message: printPass$f()
  } : {
    pass: false,
    message: printFail$f()
  };
});

const printPass$e = () => () => `${matcherHint('.not.toBeCalledOn', 'sinon.spy', 'obj')}\n\n` + `Expected spy to have ${printExpected('not been called on obj')}, ` + `instead received a spy that has ${printReceived('been called on obj')}`;

const printFail$e = () => () => `${matcherHint('.toBeCalledOn', 'sinon.spy', 'obj')}\n\n` + `Expected spy to have ${printExpected('been called on obj')}, ` + `instead received a spy that has ${printReceived('been called on obj')}`;

var assertion$e = ((expected, obj) => {
  return expected.calledOn(obj) ? {
    pass: true,
    message: printPass$e()
  } : {
    pass: false,
    message: printFail$e()
  };
});

const printPass$d = spy => () => `${matcherHint('.not.toBeCalledOnce', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('not been called once')}, ` + `instead received a spy that has been called ${printReceived(spy.callCount)} time(s)`;

const printFail$d = spy => () => `${matcherHint('.toBeCalledOnce', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('been called once')}, ` + `instead received a spy that has been called ${printReceived(spy.callCount)} time(s)`;

var assertion$d = (expected => {
  return expected.calledOnce ? {
    pass: true,
    message: printPass$d(expected)
  } : {
    pass: false,
    message: printFail$d(expected)
  };
});

const printPass$c = () => () => `${matcherHint('.not.toBeCalledOnceWith', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('not been called with correct arguments')}, ` + `instead received a spy that has ${printReceived('been called with correct arguments')}`;

const printFail$c = () => () => `${matcherHint('.toBeCalledOnceWith', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('been called with correct arguments')}, ` + `instead received a spy that has ${printReceived('not been called with correct arguments')}`;

var assertion$c = ((expected, ...rest) => {
  return expected.calledOnceWith(...rest) ? {
    pass: true,
    message: printPass$c()
  } : {
    pass: false,
    message: printFail$c()
  };
});

const printPass$b = () => () => `${matcherHint('.not.toBeCalledOnceWithExactly', 'sinon.spy', 'obj')}\n\n` + `Expected spy to have ${printExpected('not been called with correct arguments')}, ` + `instead received a spy that has ${printReceived('been called with correct arguments')}`;

const printFail$b = () => () => `${matcherHint('.toBeCalledOnceWithExactly', 'sinon.spy', 'obj')}\n\n` + `Expected spy to have ${printExpected('been called with correct arguments')}, ` + `instead received a spy that has ${printReceived('not been called with correct arguments')}`;

var assertion$b = ((expected, ...rest) => {
  return expected.calledOnceWithExactly(...rest) ? {
    pass: true,
    message: printPass$b()
  } : {
    pass: false,
    message: printFail$b()
  };
});

const printPass$a = spy => () => `${matcherHint('.not.toBeCalledThrice', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('not been called thrice')}, ` + `instead received a spy that has been called ${printReceived(spy.callCount)} time(s)`;

const printFail$a = spy => () => `${matcherHint('.toBeCalledThrice', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('been called thrice')}, ` + `instead received a spy that has been called ${printReceived(spy.callCount)} time(s)`;

var assertion$a = (expected => {
  return expected.calledThrice ? {
    pass: true,
    message: printPass$a(expected)
  } : {
    pass: false,
    message: printFail$a(expected)
  };
});

const printPass$9 = spy => () => `${matcherHint('.not.toBeCalledTwice', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('not been called twice')}, ` + `instead received a spy that has been called ${printReceived(spy.callCount)} time(s)`;

const printFail$9 = spy => () => `${matcherHint('.toBeCalledTwice', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('been called twice')}, ` + `instead received a spy that has been called ${printReceived(spy.callCount)} time(s)`;

var assertion$9 = (expected => {
  return expected.calledTwice ? {
    pass: true,
    message: printPass$9(expected)
  } : {
    pass: false,
    message: printFail$9(expected)
  };
});

const printPass$8 = () => () => `${matcherHint('.not.toBeCalledWith', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('not been called with correct arguments')}, ` + `instead received a spy that has ${printReceived('been called with correct arguments')}`;

const printFail$8 = () => () => `${matcherHint('.toBeCalledWith', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('been called with correct arguments')}, ` + `instead received a spy that has ${printReceived('not been called with correct arguments')}`;

var assertion$8 = ((expected, ...rest) => {
  if (isSinonSpy(expected)) {
    return expected.calledWith(...rest) ? {
      pass: true,
      message: printPass$8()
    } : {
      pass: false,
      message: printFail$8()
    };
  }

  return spyMatchers.toHaveBeenCalledWith(expected, ...rest);
});

const printPass$7 = () => () => `${matcherHint('.not.toBeCalledWithExactly', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('not been called with correct arguments')}, ` + `instead received a spy that has ${printReceived('been called with correct arguments')}`;

const printFail$7 = () => () => `${matcherHint('.toBeCalledWithExactly', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('been called with correct arguments')}, ` + `instead received a spy that has ${printReceived('not been called with correct arguments')}`;

var assertion$7 = ((expected, ...rest) => {
  return expected.calledWithExactly(...rest) ? {
    pass: true,
    message: printPass$7()
  } : {
    pass: false,
    message: printFail$7()
  };
});

const printPass$6 = () => () => `${matcherHint('.not.toBeCalledWithMatch', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('not been called with correct arguments')}, ` + `instead received a spy that has ${printReceived('been called with correct arguments')}`;

const printFail$6 = () => () => `${matcherHint('.toBeCalledWithMatch', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('been called with correct arguments')}, ` + `instead received a spy that has ${printReceived('not been called with correct arguments')}`;

var assertion$6 = ((expected, ...rest) => {
  return expected.calledWithMatch(...rest) ? {
    pass: true,
    message: printPass$6()
  } : {
    pass: false,
    message: printFail$6()
  };
});

const printPass$5 = () => () => `${matcherHint('.not.toBeCalledWithNew', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('not been called with new')}, ` + `instead received a spy that has ${printReceived('been called with new')}`;

const printFail$5 = () => () => `${matcherHint('.toBeCalledWithNew', 'sinon.spy', '')}\n\n` + `Expected spy to have ${printExpected('been called with new')}, ` + `instead received a spy that has ${printReceived('not been called with new')}`;

var assertion$5 = (expected => {
  return expected.calledWithNew() ? {
    pass: true,
    message: printPass$5()
  } : {
    pass: false,
    message: printFail$5()
  };
});

const printPass$4 = (expected, actual) => () => `${matcherHint('.not.toHaveCallCount', 'sinon.spy', 'callCount')}\n\n` + `Expected spy to have not been called ${printExpected(expected)} time(s), ` + `instead received a spy that has been called ${printReceived(actual.callCount)} time(s)`;

const printFail$4 = (expected, actual) => () => `${matcherHint('.toHaveCallCount', 'sinon.spy', 'callCount')}\n\n` + `Expected spy to have been called ${printExpected(expected)} time(s), ` + `instead received a spy that has been called ${printReceived(actual.callCount)} time(s)`;

var assertion$4 = ((actual, expected) => {
  if (isSinonSpy(actual)) {
    return expected === actual.callCount ? {
      pass: true,
      message: printPass$4(expected, actual)
    } : {
      pass: false,
      message: printFail$4(expected, actual)
    };
  }

  return spyMatchers.toHaveBeenCalledTimes(actual, expected);
});

const printPass$3 = () => () => `${matcherHint('.not.toHaveReturnedWith', 'sinon.spy', 'obj')}\n\n` + `Expected spy to have ${printExpected('not returned obj')}, ` + `instead received a spy that has ${printReceived('returned obj')}`;

const printFail$3 = () => () => `${matcherHint('.toHaveReturnedWith', 'sinon.spy', 'obj')}\n\n` + `Expected spy to have ${printExpected('been returned obj')}, ` + `instead received a spy that has ${printReceived('not returned obj')}`;

var assertion$3 = ((expected, obj) => {
  if (isSinonSpy(expected)) {
    return expected.returned(obj) ? {
      pass: true,
      message: printPass$3()
    } : {
      pass: false,
      message: printFail$3()
    };
  }

  return spyMatchers.toReturnWith(expected, obj);
});

const printPass$2 = () => () => `${matcherHint('.not.toHaveAlwaysReturnedWith', 'sinon.spy', 'obj')}\n\n` + `Expected spy to have ${printExpected('not returned obj')}, ` + `instead received a spy that has ${printReceived('returned obj')}`;

const printFail$2 = () => () => `${matcherHint('.toHaveAlwaysReturnedWith', 'sinon.spy', 'obj')}\n\n` + `Expected spy to have ${printExpected('been returned obj')}, ` + `instead received a spy that has ${printReceived('not returned obj')}`;

var assertion$2 = ((expected, obj) => {
  return expected.alwaysReturned(obj) ? {
    pass: true,
    message: printPass$2()
  } : {
    pass: false,
    message: printFail$2()
  };
});

/**
 * A hack to get around the Package entry points used by jest
 */
// eslint-disable-next-line import/no-dynamic-require

const toThrowMatchers = require(`${path.dirname(require.resolve('expect'))}/toThrowMatchers.js`).default;

const printPass$1 = () => () => `${matcherHint('.not.toHaveThrown', 'sinon.spy', 'TypeError | obj')}\n\n` + `Expected spy to have ${printExpected('not thrown an error')}, ` + `instead received a spy that has ${printReceived('thrown an error')}`;

const printFail$1 = () => () => `${matcherHint('.toHaveThrown', 'sinon.spy', 'TypeError | obj')}\n\n` + `Expected spy to have ${printExpected('thrown an error')}, ` + `instead received a spy that has ${printReceived('not thrown an error')}`;

var assertion$1 = ((expected, errorObjOrErrorTypeStringOrNothing) => {
  if (isSinonSpy(expected)) {
    return expected.threw(errorObjOrErrorTypeStringOrNothing) ? {
      pass: true,
      message: printPass$1()
    } : {
      pass: false,
      message: printFail$1()
    };
  }

  return toThrowMatchers.toThrow(expected, errorObjOrErrorTypeStringOrNothing);
});

const printPass = () => () => `${matcherHint('.not.toHaveAlwaysThrown', 'sinon.spy', 'TypeError | obj')}\n\n` + `Expected spy to have ${printExpected('not thrown an error')}, ` + `instead received a spy that has ${printReceived('thrown an error')}`;

const printFail = () => () => `${matcherHint('.toHaveAlwaysThrown', 'sinon.spy', 'TypeError | obj')}\n\n` + `Expected spy to have ${printExpected('thrown an error')}, ` + `instead received a spy that has ${printReceived('not thrown an error')}`;

var assertion = ((expected, errorObjOrErrorTypeStringOrNothing) => {
  return expected.alwaysThrew(errorObjOrErrorTypeStringOrNothing) ? {
    pass: true,
    message: printPass()
  } : {
    pass: false,
    message: printFail()
  };
});

var matchers = /*#__PURE__*/Object.freeze({
  __proto__: null,
  toBeAlwaysCalledOn: assertion$o,
  toHaveBeenAlwaysCalledOn: assertion$o,
  toBeAlwaysCalledWith: assertion$n,
  toHaveBeenAlwaysCalledWith: assertion$n,
  toBeAlwaysCalledWithExactly: assertion$m,
  toHaveBeenAlwaysCalledWithExactly: assertion$m,
  toBeAlwaysCalledWithMatch: assertion$l,
  toHaveBeenAlwaysCalledWithMatch: assertion$l,
  toBeAlwaysCalledWithNew: assertion$k,
  toHaveBeenAlwaysCalledWithNew: assertion$k,
  toBeCalled: assertion$j,
  toHaveBeenCalled: assertion$j,
  toBeCalledAfter: assertion$i,
  toHaveBeenCalledAfter: assertion$i,
  toBeCalledBefore: assertion$h,
  toHaveBeenCalledBefore: assertion$h,
  toHaveBeenCalledImmediatelyAfter: assertion$g,
  toBeCalledImmediatelyAfter: assertion$g,
  toBeCalledImmediatelyBefore: assertion$f,
  toHaveBeenCalledImmediatelyBefore: assertion$f,
  toBeCalledOn: assertion$e,
  toHaveBeenCalledOn: assertion$e,
  toBeCalledOnce: assertion$d,
  toHaveBeenCalledOnce: assertion$d,
  toBeCalledOnceWith: assertion$c,
  toHaveBeenCalledOnceWith: assertion$c,
  toBeCalledOnceWithExactly: assertion$b,
  toHaveBeenCalledOnceWithExactly: assertion$b,
  toBeCalledThrice: assertion$a,
  toHaveBeenCalledThrice: assertion$a,
  toBeCalledTwice: assertion$9,
  toHaveBeenCalledTwice: assertion$9,
  toBeCalledWith: assertion$8,
  toHaveBeenCalledWith: assertion$8,
  toBeCalledWithExactly: assertion$7,
  toHaveBeenCalledWithExactly: assertion$7,
  toBeCalledWithMatch: assertion$6,
  toHaveBeenCalledWithMatch: assertion$6,
  toBeCalledWithNew: assertion$5,
  toHaveBeenCalledWithNew: assertion$5,
  toHaveCallCount: assertion$4,
  toHaveBeenCalledTimes: assertion$4,
  toBeCalledTimes: assertion$4,
  toHaveReturnedWith: assertion$3,
  toReturnWith: assertion$3,
  toHaveReturned: assertion$3,
  toReturn: assertion$3,
  toHaveAlwaysReturnedWith: assertion$2,
  toAlwaysReturnWith: assertion$2,
  toHaveThrown: assertion$1,
  toHaveThrownError: assertion$1,
  toThrow: assertion$1,
  toThrowError: assertion$1,
  toHaveAlwaysThrown: assertion,
  toHaveAlwaysThrownError: assertion,
  toAlwaysThrow: assertion,
  toAlwaysThrowError: assertion
});

/* eslint-disable no-console */
const jestExpect = global.expect;

if (jestExpect !== undefined) {
  jestExpect.extend(matchers);
} else {
  console.error("Unable to find Jest's global expect");
}
